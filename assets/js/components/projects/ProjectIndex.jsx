import React, { Component, PropTypes } from "react"
import { bindActionCreators } from "redux"
import { connect } from "react-redux"
import { withRouter } from "react-router"
import { createProject } from "../../api"
import * as actions from "../../actions/projects"
import * as projectActions from "../../actions/project"
import {
  AddButton,
  EmptyPage,
  CardTable,
  SortableHeader,
  UntitledIfEmpty,
  ArchiveIcon,
  ArchiveFilter,
  PagingFooter,
} from "../ui"
import * as routes from "../../routes"
import range from "lodash/range"
import { orderedItems } from "../../reducers/collection"
import { FormattedDate } from "react-intl"
import { translate } from "react-i18next"

class ProjectIndex extends Component {
  componentWillMount() {
    this.creatingProject = false

    this.props.projectActions.clearProject()
    this.fetchProjects()
  }

  newProject(e) {
    e.preventDefault()

    // Prevent multiple clicks to create multiple projects
    if (this.creatingProject) return
    this.creatingProject = true

    let theProject
    createProject({ name: "" })
      .then((response) => {
        theProject = response.entities.projects[response.result]
        this.props.projectActions.createProject(theProject)
      })
      .then(() => {
        this.creatingProject = false
        this.navigateToProject(theProject.id)
      })
  }

  nextPage() {
    this.props.actions.nextProjectsPage()
  }

  previousPage() {
    this.props.actions.previousProjectsPage()
  }

  sortBy(property) {
    this.props.actions.sortProjectsBy(property)
  }

  archiveOrUnarchive(project: Project, action: string) {
    const { t, actions, startIndex } = this.props
    actions.archiveOrUnarchive(project, action).then(() => {
      const { projects } = this.props
      if (projects.length == 0 && startIndex > 0) {
        actions.previousProjectsPage()
      }
      const description =
        action == "unarchive"
          ? t("Project successfully unarchived")
          : t("Project successfully archived")
      window.Materialize.toast(description, 5000)
    })
  }

  fetchProjects(archived: boolean = false) {
    this.props.actions.fetchProjects({ archived: archived })
  }

  archiveIconForProject(archived: boolean, project: Project) {
    if (!project.owner) {
      return <td />
    } else {
      const action = archived ? "unarchive" : "archive"
      const onClick = () => this.archiveOrUnarchive(project, action)
      return (
        <td className="action">
          <ArchiveIcon archived={archived} onClick={onClick} />
        </td>
      )
    }
  }

  navigateToProject(projectId) {
    const { router } = this.props
    router.push(routes.project(projectId))
  }

  render() {
    const { archived, t } = this.props
    return (
      <div>
        <AddButton text={t("Add project")} onClick={(e) => this.newProject(e)} />
        <div className="row">
          <ArchiveFilter
            archived={archived}
            onChange={(selection) => this.fetchProjects(selection == "archived")}
          />
        </div>
        {this.renderTable()}
      </div>
    )
  }

  renderTable() {
    const { projects, sortBy, sortAsc, pageSize, startIndex, endIndex, totalCount, archived, t } =
      this.props

    if (!projects) {
      return (
        <div>
          <CardTable title={t("Loading projects...")} highlight />
        </div>
      )
    }

    const title = `${totalCount} ${totalCount == 1 ? t("project") : t("projects")}`
    const footer = (
      <PagingFooter
        {...{ startIndex, endIndex, totalCount }}
        onPreviousPage={() => this.previousPage()}
        onNextPage={() => this.nextPage()}
      />
    )

    return (
      <div>
        {projects.length == 0 && !archived ? (
          <div className="empty-projects">
            <EmptyPage
              icon="folder"
              title={t("You have no active projects")}
              onClick={(e) => this.newProject(e)}
              createText={t("Create one", { context: "project" })}
            />
            <div className="organize">
              <div className="icons">
                <i className="material-icons">assignment_turned_in</i>
                <i className="material-icons">assignment</i>
                <i className="material-icons">perm_phone_msg</i>
                <i className="material-icons">folder_shared</i>
              </div>
              <p>
                <b>{t("Organize your work")}</b>
                <br />
                {t("Manage surveys, questionnaires, and collaborators for each of your projects.")}
              </p>
            </div>
          </div>
        ) : (
          <CardTable title={title} footer={footer} highlight>
            <colgroup>
              <col width="50%" />
              <col width="20%" />
              <col width="20%" />
              <col width="10%" />
            </colgroup>
            <thead>
              <tr>
                <SortableHeader
                  text={t("Name")}
                  property="name"
                  sortBy={sortBy}
                  sortAsc={sortAsc}
                  onClick={(name) => this.sortBy(name)}
                />
                <SortableHeader
                  className="right-align"
                  text={t("Running surveys")}
                  property="runningSurveys"
                  sortBy={sortBy}
                  sortAsc={sortAsc}
                  onClick={(name) => this.sortBy(name)}
                />
                <SortableHeader
                  className="right-align"
                  text={t("Last activity date")}
                  property="updatedAt"
                  sortBy={sortBy}
                  sortAsc={sortAsc}
                  onClick={(name) => this.sortBy(name)}
                />
                <th />
              </tr>
            </thead>
            <tbody>
              {range(0, pageSize).map((index) => {
                const project = projects[index]
                if (!project)
                  return (
                    <tr key={-index} className="empty-row">
                      <td colSpan="4" />
                    </tr>
                  )

                return (
                  <tr key={project.id}>
                    <td className="project-name" onClick={() => this.navigateToProject(project.id)}>
                      <UntitledIfEmpty text={project.name} emptyText={t("Untitled project")} />
                    </td>
                    <td className="right-align" onClick={() => this.navigateToProject(project.id)}>
                      {project.runningSurveys}
                    </td>
                    <td className="right-align" onClick={() => this.navigateToProject(project.id)}>
                      <FormattedDate
                        value={Date.parse(project.updatedAt)}
                        day="numeric"
                        month="short"
                        year="numeric"
                      />
                    </td>
                    {this.archiveIconForProject(archived, project)}
                  </tr>
                )
              })}
            </tbody>
          </CardTable>
        )}
      </div>
    )
  }
}

ProjectIndex.propTypes = {
  actions: PropTypes.object.isRequired,
  projectActions: PropTypes.object.isRequired,
  sortBy: PropTypes.string,
  sortAsc: PropTypes.bool.isRequired,
  projects: PropTypes.array,
  pageSize: PropTypes.number.isRequired,
  startIndex: PropTypes.number.isRequired,
  endIndex: PropTypes.number.isRequired,
  totalCount: PropTypes.number.isRequired,
  archived: PropTypes.bool,
  t: PropTypes.func,
  router: PropTypes.object,
}

const mapStateToProps = (state) => {
  let projects = orderedItems(state.projects.items, state.projects.order)
  const archived = projects ? state.projects.filter.archived : false
  const sortBy = state.projects.sortBy
  const sortAsc = state.projects.sortAsc
  const totalCount = projects ? projects.length : 0
  const pageIndex = state.projects.page.index
  const pageSize = state.projects.page.size
  if (projects) {
    projects = projects.slice(pageIndex, pageIndex + pageSize)
  }
  const startIndex = Math.min(totalCount, pageIndex + 1)
  const endIndex = Math.min(pageIndex + pageSize, totalCount)
  return {
    sortBy,
    sortAsc,
    projects,
    pageSize,
    startIndex,
    endIndex,
    totalCount,
    archived,
  }
}

const mapDispatchToProps = (dispatch) => ({
  actions: bindActionCreators(actions, dispatch),
  projectActions: bindActionCreators(projectActions, dispatch),
})

export default translate()(withRouter(connect(mapStateToProps, mapDispatchToProps)(ProjectIndex)))
